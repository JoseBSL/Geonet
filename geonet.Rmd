---
title: "Geonet"
author: "Liam Kendall"
date: "23 August 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

###NOTES
#Removed hummingbird/bird only netowrks and bee only network (M_PL_059)

##libraries


library(plyr)
library(dplyr)
library(ggplot2)
library(glmmTMB)
library(geonames)
library(gridExtra)
library(kgc)
library(MuMIn)
library(reshape2)
library(stringi)
library(stringr)
library(taxize)
library(tidyr)
library(vegan)

##Reference dataframe
reference=read.csv("data/ref/references.csv",header=T)
colnames(reference)[1]="Network"

left = function (string,char){
  substr(string,1,char)
}
reference$ID=left(reference$Network,8)
reference=reference[!duplicated(reference$ID),]
reference$Network=reference$ID

##Add climate zone
climate_zone=reference[,c("ID","Longitude","Latitude")]
climate_zone <- data.frame(climate_zone,
                   rndCoord.lon = RoundCoordinates(climate_zone$Longitude),
                   rndCoord.lat = RoundCoordinates(climate_zone$Latitude))
reference <- data.frame(reference,ClimateZ=LookupCZ(climate_zone))
reference$ClimateZ=as.character(reference$ClimateZ)
reference[26,c("ClimateZ")]=c("BWh")
reference[60,c("ClimateZ")]=c("Af")
reference$clim=left(reference$ClimateZ,1)


#Elevation
##ELEVATION DATA

ele=read.csv("data/processing/elevation.csv")
reference$ele=ele$srtm3

#http://www.gpsvisualizer.com/elevation
reference[reference$ele<0,]
reference[reference$ID %in% "M_PL_009",c("ele")] = 1009
reference[reference$ID %in% "M_PL_010",c("ele")] =  261
reference[reference$ID %in% "M_PL_014",c("ele")] = 250
reference[reference$ID %in% "M_PL_020",c("ele")] = 250
reference[reference$ID %in% "M_PL_024",c("ele")] = 92 
reference[reference$ID %in% "M_PL_026",c("ele")] = 1 #iffy
reference[reference$ID %in% "M_PL_045",c("ele")] = 1 #iffy
reference[reference$ID %in% "M_PL_052",c("ele")] = 139 
reference[reference$ID %in% "M_PL_060",c("ele")] = 1 #iffy

##remove bee only network M_PL_059

reference=reference[!reference$ID %in% "M_PL_059",]
##read in plant families from taxize

plant_family=read.csv("data/processing/plant_family.csv")
plant_order=read.csv("data/processing/plant_order.csv")
plant_family=merge(plant_order,plant_family,by="family")

#all networks into list
setwd("~/Dropbox/PhD/Rprojects/Geonet/data")
files = list.files(pattern="*.csv")
myfiles = lapply(files, function(x) read.csv(x, stringsAsFactors = FALSE, sep=","))
setwd("~/Dropbox/PhD/Rprojects/Geonet")

#NAme list objects/networks
names(myfiles)=left(files,8)
names(myfiles)

##remove bee only network M_PL_059

#Melt
myfiles.melt=melt(myfiles,id.vars=c(1))

##Extra long format networks
valerie1=read.csv("data/newdata/mauritius_valerie.csv")
valerie2=read.csv("data/newdata/ilha_das_flores_valerie.csv")

#Aggregate - merges 
myfiles.melt.agg=aggregate(value ~ X + variable+L1,data=myfiles.melt, FUN=sum)
str(myfiles.melt.agg)
str(valerie1)
#myfiles.melt.agg=rbind(myfiles.melt.agg,valerie1,valerie2)
myfiles.melt.agg$value=ifelse(myfiles.melt.agg$value > 0, 1, 0)
colnames(myfiles.melt.agg)=c("Plant","Pollinator","Network","Int")

myfiles.melt.agg.z=myfiles.melt.agg[!myfiles.melt.agg$Int==0,]
myfiles.melt.agg.z$Pollinator=gsub("\\."," ",myfiles.melt.agg.z$Pollinator)


poll_famord_5=read.csv("data/processing/poll_famord_5.csv",header=T)

### Plant / Pollinator genera columns
myfiles.melt.agg.z$PGenus=word(myfiles.melt.agg.z$Plant,1)
myfiles.melt.agg.z$IGenus=word(myfiles.melt.agg.z$Pollinator,1)

#Remove plants from bird networks - plant_family was made with these networks
minus_plant=setdiff(plant_family$PGenus,myfiles.melt.agg.z$PGenus)


#remove plant families from bird networks
plant_family_subset=plant_family[!rowSums(plant_family==minus_plant),]%>%droplevels()
  
setdiff(plant_family_subset$PGenus,myfiles.melt.agg.z$PGenus)

#add plant families
str(myfiles.melt.agg.z)
str(plant_family_subset)
myfiles.melt.agg.z <- myfiles.melt.agg.z %>% mutate_if(is.character,as.factor)
geonet=merge(myfiles.melt.agg.z,
             plant_family_subset[!duplicated(plant_family_subset$PGenus),c("PGenus","family","order")], by = "PGenus") 
str(geonet)
colnames(geonet)[7:8]=c("Pfamily","Porder")
geonet=merge(geonet,reference[,c("ele","clim","Network","Connectance","Latitude","Longitude")], by = "Network")

#add pollinator families
str(poll_famord_5)
str(geonet)
geonet=merge(geonet,poll_famord_5[,c("IGenus","Order","Family")], by = "IGenus")
colnames(geonet)[14:15]=c("PolOrder","PolFamily")
geonet <- geonet %>% mutate_if(is.factor,as.character)
geonet[geonet$PolFamily%in%c("Stenotritidae","Apidae","Andrenidae","Colletidae","Megachilidae","Melittidae","Halictidae"),c("PolOrder")]="Bee"
geonet[geonet$PolFamily%in%c("Syrphidae"),c("PolOrder")]="Syrphidae"

geonet <- geonet %>% mutate_if(is.character,as.factor)
str(geonet)

g=geonet%>%
group_by(Network, PolOrder) %>%
  summarise(order_links=sum(Int))

g2=g%>%
  group_by(Network) %>%
  summarise(int_tot=sum(order_links))

g3=merge(g,g2)

g3$prop_links=g3$order_links/g3$int_tot

g4=merge(g3,reference,by="Network")

#subset data by insect order
g.sub <- subset(g4, PolOrder %in% c("Hymenoptera", "Bee","Diptera", "Lepidoptera","Syrphidae","Coleoptera"))



```

```{r jaccard null}
#################################################
#commpute jaccadi parwise dissimilarity for null networks
#################################################

library(reshape2)
library(vegan)
library(plyr)
library(dplyr)

#################################
#start here
#################################

#cast long format dataframe
geo.wide <- dcast(geonet, Network + Plant ~ Pollinator, value.var = "Int")
geo.wide[is.na(geo.wide)] <- 0

#create empty list
null.net <- c()
null.net <- list(null.net)

#run loop over each site
for (j in levels(geo.wide[, 1])){
  web <- subset(geo.wide, Network == j)#iterate over site
  network <- as.vector(web$Network[1])
  web <- web[,c(-1,-2)]
  web = web[,colSums(web) > 0]#remove species with no links at each site
  web.names <- c(colnames(web))
  
  #Null model II from Bascompte et al. (2003). Creates random networks by probabilistically fixing row and column marginal totals. The expected number of links is same as observed number. Rodriguez-Girona and Santamaria (2006) showed that this null model has the best compromise between Type I and Type II errors
  #Run this code once to create the null model function
  null.model.II <- function(web){
    web <- as.matrix(web > 0) + 0
    # calculate the probability based on row marginals. Creates matrix same size as web, with row sums divided by number of columns (to get probability of a 1 in each cell of each row), repeated across all columns for each row.
    row.probs <- matrix(rowSums(web)/ncol(web),nrow(web),ncol(web))
    # calculate the probability based on column marginals (again, repeated for whole column). Transpose used instead of byrow=T
    col.probs <- t(matrix(colSums(web)/nrow(web),ncol(web),nrow(web)))
    # calculate the element by element mean of this probabilities
    mat.probs <- (row.probs + col.probs) / 2.0
    # generate a random matrix with 1s proportional to the above probabilities. rbinom(n, size, prob) n is number of observations, size is number of trials, prob is prob of success in each trial
    mat.null <- matrix(rbinom(nrow(web)*ncol(web),1,as.vector(mat.probs)),nrow(web),ncol(web))  
    # return that matrix in all its glory
    return(mat.null)
  }
  
  #Begin permutation test (two tailed)
  reps <- 999 #set number of permutations
  
  #Create a list with spaces for each output matrix  
  nulls<-vector("list",reps)  
  for (i in 1:reps) {
    nulls[[i]]<-null.model.II(web)
  }
  
  #call any individual matrix from that list using nulls[[x]], where x is the number of the matrix you want to call
  null.list <- vector("list") 
  for (i in 1:reps) {
    null.list[[i]] <- as.matrix(vegdist(t(nulls[[i]]), "jaccard", binary=T, upper = T))#add colMeans if this doesn't work
  }

  #this convers naNs to 1... not sure if that's correct
  #becasue null model omits some species sometimes
  null.list <- rapply(null.list, f=function(x) ifelse(is.nan(x),1,x), how="replace" )

  #compute means and standard deviation for each species pair 
  null.mean <- apply(simplify2array(null.list), 1:2, mean)
  colnames(null.mean) <- web.names
  rownames(null.mean) <- web.names
  null.mean <- melt(null.mean, value.name="mean")
  null.sd <- apply(simplify2array(null.list), 1:2, sd)
  colnames(null.sd) <- web.names
  rownames(null.sd) <- web.names
  null.sd <- melt(null.sd,value.name="sd")
  null.mean.sd <- merge(null.mean,null.sd, by=c("Var1","Var2"))
  null.mean.sd <- null.mean.sd[!null.mean.sd$Var1==null.mean.sd$Var2,]
  null.mean.sd$network <- network
  
  #print into list
  null.net[[j]] <- null.mean.sd
  
}
  
#convert list to dataframe
null.net <- rbind.fill(lapply(null.net, as.data.frame))

#################################
#END
#################################

range(null.net$mean)
setdiff(myfiles.jac.long$Poll_sp2,null.net$Var1)

str(myfiles.jac.long)
str(myfiles.melt)
myfiles.melt[myfiles.melt$variable%in%"Larra.sp1.M_PL_055",]

```


```{r jaccard}
remove_zero_cols <- function(df) {
  rem_vec <- NULL
  for(i in 1:ncol(df)){
    this_sum <- summary(df[,i])
    zero_test <- length(which(this_sum == 0))
    if(zero_test == 6) {
      rem_vec[i] <- names(df)[i]
    }
  }
  features_to_remove <- rem_vec[!is.na(rem_vec)]
  rem_ind <- which(names(df) %in% features_to_remove)
  df <- df[,-rem_ind]
  return(df)
}

geo.split <- split(geo.wide,geo.wide$Network)

geo.split=lapply(geo.split,function(x)remove_zero_cols(x))

geo.split.jac=lapply(geo.split,function(x) vegdist(t(x[,3:length(x)]), method="jaccard",upper=T,binary=T))
geo.split.jac.long=lapply(geo.split.jac,function(x) melt(as.matrix(x)))
geo.split.jac.long=do.call("rbind",geo.split.jac.long)

geo.split.jac.long$Network=left(rownames(geo.split.jac.long),8)

head(geo.split.jac.long)
colnames(geo.split.jac.long)[1:2]=c("Poll_sp1","Poll_sp2")

str(geo.split.jac.long)

#GENUS 1
geo.split.jac.long$IGenus=word(gsub("\\."," ",geo.split.jac.long$Poll_sp1),1)

str(geo.split.jac.long)
geo.split.jac.long=merge(geo.split.jac.long,poll_famord_5[,c("IGenus","Order","Family")], by = "IGenus")

colnames(geo.split.jac.long)=c("PGenus1","Poll_sp1","Poll_sp2","jac","Network","Order1","Family1")

#GENUS 2
geo.split.jac.long$IGenus=word(gsub("\\."," ",geo.split.jac.long$Poll_sp2),1)

geo.split.jac.long=merge(geo.split.jac.long,poll_famord_5[,c("IGenus","Order","Family")], by = "IGenus")
str(geo.split.jac.long)

colnames(geo.split.jac.long)=c("PGenus2","PGenus1","Poll_sp1","Poll_sp2","jac","Network","Order1","Family1","Order2","Family2")
str(geo.split.jac.long)

geo.split.jac.long=merge(geo.split.jac.long,reference[,c("Latitude","Longitude","clim","Network","Connectance","ele")], by = "Network")
str(geo.split.jac.long)
head(geo.split.jac.long)

#MERGE WITH NULL DISTRIBUTION#####
setdiff(geo.split.jac.long$Poll_sp2,null.net$Poll_sp2)


null.geo=merge(geo.split.jac.long,null.net,by=c("Poll_sp1","Poll_sp2","Network"))%>%droplevels()
str(geo.split.jac.long)

#########SUBSET########
null.geo <- null.geo %>% mutate_if(is.factor,as.character)
null.geo[null.geo$Family1%in%c("Stenotritidae","Apidae","Andrenidae","Colletidae","Megachilidae","Melittidae","Halictidae"),c("Order1")]="Bee"
null.geo[null.geo$Family1%in%c("Syrphidae"),c("Order1")]="Syrphidae"

null.geo[null.geo$Family2%in%c("Stenotritidae","Apidae","Andrenidae","Colletidae","Megachilidae","Melittidae","Halictidae"),c("Order1")]="Bee"
null.geo[null.geo$Family2%in%c("Syrphidae"),c("Order1")]="Syrphidae"

null.geo.sub1=subset(null.geo, Order1 %in% c("Hymenoptera", "Bee","Diptera", "Lepidoptera","Syrphidae","Coleoptera"))
null.geo.sub1=subset(null.geo.sub1, Order2 %in% c("Hymenoptera", "Bee","Diptera", "Lepidoptera","Syrphidae","Coleoptera"))
null.geo.sub1 <- null.geo.sub1 %>% mutate_if(is.character,as.factor)

null.geo.sub1$jac.fam=as.factor(paste(null.geo.sub1$Family1,null.geo.sub1$Family2,sep="_"))
null.geo.sub1$jac.ord=as.factor(paste(null.geo.sub1$Order1,null.geo.sub1$Order2,sep="_"))

null.geo.sub1$jac.ord

```


```{r dissimilarity}

####PLANT FAMILY DISSIMILARITY####
pfdist=geonet %>% group_by(Network,clim,ele) %>% count(Pfamily)
pfdist=dcast(pfdist, Network + clim +ele ~ Pfamily, 
      fun.aggregate = sum, na.rm =T, value.var="n", fill = 0)
rownames(pfdist)=pfdist[,1]
str(pfdist)

pfdist.matrix=vegdist(pfdist[,4:length(pfdist)],method="jaccard",binary=TRUE) #Presence-absence

mj=metaMDS(pfdist.matrix)

NMDS = data.frame(MDS1 = mj$points[,1], MDS2 = mj$points[,2],site=unique(pfdist$Network), clim=pfdist$clim)

#unable to create ellipse for B (to few points)... need to add them manually at some stage
NMDS <- subset(NMDS, clim %in% c("A", "C","D", "E"))%>%droplevels

#create ellipse function (this is hidden in vegan)
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100)
{
  theta <- (0:npoints) * 2 * pi/npoints
  Circle <- cbind(cos(theta), sin(theta))
  t(center + scale * t(Circle %*% chol(cov)))
}

df_ell <- data.frame()
for(g in levels(NMDS$clim)){
  df_ell <- rbind(df_ell, cbind(as.data.frame(with(NMDS[NMDS$clim==g,],
                                                   veganCovEllipse(cov.wt(cbind(MDS1,MDS2),wt=rep(1/length(MDS1),length(MDS1)))$cov,center=c(mean(MDS1),mean(MDS2)))))
                                ,group=g))
}

p <- ggplot(data = NMDS, aes(MDS1, MDS2))
p <- p + geom_point(aes(colour = clim), size=2)
#p <- p + geom_text(aes(label = site, colour=landuse), vjust = -0.8)
p <- p + geom_path(data=df_ell, aes(x=MDS1, y=MDS2,colour=group), size=1, linetype=2)
p <- p + theme(panel.grid.minor = element_blank(),
               panel.background = element_blank(),
               axis.line = element_line(colour = "black")) +
  theme(panel.border=element_rect(colour = "black", fill = "NA", size = 1)) +
  theme(axis.text.y=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =12),
        axis.title.y=element_text(size=16, vjust = 1),
        axis.text.x=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =12),
        axis.title.x=element_text(size=16, vjust = 1),
        axis.text=element_text(colour = "black"))
p <- p + theme(axis.title.y=element_text(margin=margin(0,20,0,0)))
p <- p + scale_colour_brewer(palette = "Dark2")

#################
#pollinator dissimilarity
####################
poldist=geonet %>% group_by(Network,clim,ele) %>% count(PolFamily)

poldist=dcast(poldist, Network + clim + ele ~ PolFamily, 
              fun.aggregate = sum, na.rm =T, value.var="n", fill = 0)
rownames(poldist)=poldist[,1]

poldist.matrix=vegdist(poldist[,4:length(poldist)],method="jaccard",binary=TRUE) #Presence-absence

mj2=metaMDS(poldist.matrix)

NMDS1 = data.frame(MDS1 = mj2$points[,1], MDS2 = mj2$points[,2],site=unique(poldist$Network), clim=poldist$clim)

#unable to create ellipse for B (to few points)... need to add them manually at some stage
NMDS1 <- subset(NMDS1, clim %in% c("A", "C","D", "E"))%>%droplevels

#create ellipse function (this is hidden in vegan)
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100)
{
  theta <- (0:npoints) * 2 * pi/npoints
  Circle <- cbind(cos(theta), sin(theta))
  t(center + scale * t(Circle %*% chol(cov)))
}

df_ell <- data.frame()
for(g in levels(NMDS1$clim)){
  df_ell <- rbind(df_ell, cbind(as.data.frame(with(NMDS1[NMDS1$clim==g,],
                                                   veganCovEllipse(cov.wt(cbind(MDS1,MDS2),wt=rep(1/length(MDS1),length(MDS1)))$cov,center=c(mean(MDS1),mean(MDS2)))))
                                ,group=g))
}

p1 <- ggplot(data = NMDS1, aes(MDS1, MDS2))
p1 <- p1 + geom_point(aes(colour = clim), size=2)
#p <- p + geom_text(aes(label = site, colour=landuse), vjust = -0.8)
p1 <- p1 + geom_path(data=df_ell, aes(x=MDS1, y=MDS2,colour=group), size=1, linetype=2)
p1 <- p1 + theme(panel.grid.minor = element_blank(),
               panel.background = element_blank(),
               axis.line = element_line(colour = "black")) +
  theme(panel.border=element_rect(colour = "black", fill = "NA", size = 1)) +
  theme(axis.text.y=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =12),
        axis.title.y=element_text(size=16, vjust = 1),
        axis.text.x=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =12),
        axis.title.x=element_text(size=16, vjust = 1),
        axis.text=element_text(colour = "black"))
p1 <- p1 + theme(axis.title.y=element_text(margin=margin(0,20,0,0)))
p1 <- p1 + scale_colour_brewer(palette = "Dark2")


###PLOT BOTH TOGETHER
grid.arrange(p,p1)

```

```{r dissimilarity tests}

adonis(pfdist.matrix ~ pfdist$clim+pfdist$ele, permutations = 9999)
adonis(pfdist.matrix ~ pfdist$clim*scale(pfdist$ele), permutations = 9999)
adonis(pfdist.matrix ~ pfdist$clim+scale(pfdist$ele), permutations = 9999)
#very small amount explained by elevation

beta_plant=betadisper(pfdist.matrix, pfdist$clim, type = c("centroid"))
TukeyHSD(beta_plant) ## A FEW BAD

adonis(poldist.matrix ~ pfdist$clim+pfdist$ele, permutations = 9999)
adonis(poldist.matrix ~ pfdist$clim*scale(pfdist$ele), permutations = 9999)
adonis(poldist.matrix ~ pfdist$clim+scale(pfdist$ele), permutations = 9999)
#more explained by elevation

beta_poll=betadisper(poldist.matrix, poldist$clim, type = c("centroid"))
TukeyHSD(beta_poll) ##ALL GOOD

##procrustes
pol.plant.pro=protest(poldist.matrix, pfdist.matrix,permutations=999)
pol.plant.pro

ctest <- data.frame(rda1=pol.plant.pro$Yrot[,1],
                    rda2=pol.plant.pro$Yrot[,2],xrda1=pol.plant.pro$X[,1],
                    xrda2=pol.plant.pro$X[,2])

p3=ggplot(ctest) +
  geom_point(aes(x=rda1, y=rda2),pch=1) +
  geom_point(aes(x=xrda1, y=xrda2),pch=2) +
  geom_segment(aes(x=xrda1,y=xrda2,xend=rda1,yend=rda2),arrow=arrow(length=unit(0.2,"cm")))+
  theme_bw()+ylab("Dimension 2")+xlab("Dimension 1")+theme(aspect.ratio = 1)
p3
```


```{r test prop links across climate and elevation}
library(MuMIn)
library(lme4)
library(stargazer)
library(DHARMa)
g.sub

reference$clim=ordered(reference$clim)
str(reference$ele)

##FULL MODEL - THREE WAY INTERACTION
prop1=glmmTMB(prop_links~PolOrder*scale(ele)*clim+(1|Network),
              family=beta_family(link = "logit"),
              data=g.sub)
#plot(residuals(prop1)~fitted(prop1))
#prop.res=simulateResiduals(prop1)
#plot(prop.res)

summary(prop1)

prop.dredge=dredge(prop1)

prop.mods=get.models(prop.dredge, subset = delta < 4)
summary(prop.mods[[1]])


sjPlot::plot_model(prop.mods[[1]],vline.color="black")+theme_bw()

```



```{r}



```


