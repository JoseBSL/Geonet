---
title: "Geonet"
author: "Liam Kendall"
date: "23 August 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

###NOTES
#Removed hummingbird/bird only netowrks and bee only network (M_PL_059)

##libraries
library(bayesplot)
library(brms)
library(plyr)
library(dplyr)
library(emmeans)
library(ggplot2)

library(glmmTMB)
library(geonames)
library(gridExtra)
library(kgc)
library(MuMIn)
library(reshape2)
library(stringi)
library(stringr)
library(taxize)
library(tidyr)
library(vegan)
```


```{r}
##Reference dataframe
reference=read.csv("data/ref/references.csv",header=T)
colnames(reference)[1]="Network"

left = function (string,char){
  substr(string,1,char)
}
reference$ID=left(reference$Network,8)
reference=reference[!duplicated(reference$ID),]
reference$Network=reference$ID

##Add climate zone
climate_zone=reference[,c("ID","Longitude","Latitude")]
climate_zone <- data.frame(climate_zone,
                   rndCoord.lon = RoundCoordinates(climate_zone$Longitude),
                   rndCoord.lat = RoundCoordinates(climate_zone$Latitude))
reference <- data.frame(reference,ClimateZ=LookupCZ(climate_zone))
reference$ClimateZ=as.character(reference$ClimateZ)
reference[26,c("ClimateZ")]=c("BWh")
reference[60,c("ClimateZ")]=c("Af")
reference$clim=left(reference$ClimateZ,1)


#Elevation
##ELEVATION DATA

ele=read.csv("data/processing/elevation.csv")
reference$ele=ele$srtm3

#http://www.gpsvisualizer.com/elevation
reference[reference$ele<0,]
reference[reference$ID %in% "M_PL_009",c("ele")] = 1009
reference[reference$ID %in% "M_PL_010",c("ele")] =  261
reference[reference$ID %in% "M_PL_014",c("ele")] = 250
reference[reference$ID %in% "M_PL_020",c("ele")] = 250
reference[reference$ID %in% "M_PL_024",c("ele")] = 92 
reference[reference$ID %in% "M_PL_026",c("ele")] = 1 #iffy
reference[reference$ID %in% "M_PL_045",c("ele")] = 1 #iffy
reference[reference$ID %in% "M_PL_052",c("ele")] = 139 
reference[reference$ID %in% "M_PL_060",c("ele")] = 1 #iffy

##remove bee only network M_PL_059

reference=reference[!reference$ID %in% "M_PL_059",]
##read in plant families from taxize

plant_family=read.csv("data/processing/plant_family.csv")
plant_order=read.csv("data/processing/plant_order.csv")
plant_family=merge(plant_order,plant_family,by="family")

geonet=read.csv("data/processed/geonet.csv")
nullg=read.csv("data/processed/null_niche.csv")
g=geonet%>%
group_by(Network, PolOrder) %>%
  summarise(order_links=sum(Int))

g2=g%>%
  group_by(Network) %>%
  summarise(int_tot=sum(order_links))

g3=merge(g,g2)

g3$prop_links=g3$order_links/g3$int_tot

g4=merge(g3,reference,by="Network")

#subset data by insect order
g.sub <- subset(g4, PolOrder %in% c("Hymenoptera", "Bee","Diptera", "Lepidoptera","Syrphidae","Coleoptera"))
```

```{r}
#all networks into list
setwd("~/Dropbox/PhD/Rprojects/Geonet/data")
files = list.files(pattern="*.csv")
myfiles = lapply(files, function(x) read.csv(x, stringsAsFactors = FALSE, sep=","))
setwd("~/Dropbox/PhD/Rprojects/Geonet")

#NAme list objects/networks
names(myfiles)=left(files,8)
names(myfiles)

##remove bee only network M_PL_059

#Melt
myfiles.melt=melt(myfiles,id.vars=c(1))

##Extra long format networks
valerie1=read.csv("data/newdata/mauritius_valerie.csv")
valerie2=read.csv("data/newdata/ilha_das_flores_valerie.csv")

#Aggregate - merges 
myfiles.melt.agg=aggregate(value ~ X + variable+L1,data=myfiles.melt, FUN=sum)
str(myfiles.melt.agg)
str(valerie1)
#myfiles.melt.agg=rbind(myfiles.melt.agg,valerie1,valerie2)
myfiles.melt.agg$value=ifelse(myfiles.melt.agg$value > 0, 1, 0)
colnames(myfiles.melt.agg)=c("Plant","Pollinator","Network","Int")

myfiles.melt.agg.z=myfiles.melt.agg[!myfiles.melt.agg$Int==0,]
myfiles.melt.agg.z$Pollinator=gsub("\\."," ",myfiles.melt.agg.z$Pollinator)


poll_famord_5=read.csv("data/processing/poll_famord_5.csv",header=T)

### Plant / Pollinator genera columns
myfiles.melt.agg.z$PGenus=word(myfiles.melt.agg.z$Plant,1)
myfiles.melt.agg.z$IGenus=word(myfiles.melt.agg.z$Pollinator,1)

#Remove plants from bird networks - plant_family was made with these networks
minus_plant=setdiff(plant_family$PGenus,myfiles.melt.agg.z$PGenus)


#remove plant families from bird networks
plant_family_subset=plant_family[!rowSums(plant_family==minus_plant),]%>%droplevels()
  
setdiff(plant_family_subset$PGenus,myfiles.melt.agg.z$PGenus)

#add plant families
str(myfiles.melt.agg.z)
str(plant_family_subset)
myfiles.melt.agg.z <- myfiles.melt.agg.z %>% mutate_if(is.character,as.factor)
geonet=merge(myfiles.melt.agg.z,
             plant_family_subset[!duplicated(plant_family_subset$PGenus),c("PGenus","family","order")], by = "PGenus") 
str(geonet)
colnames(geonet)[7:8]=c("Pfamily","Porder")
geonet=merge(geonet,reference[,c("ele","clim","Network","Connectance","Latitude","Longitude")], by = "Network")

#add pollinator families
str(poll_famord_5)
str(geonet)
geonet=merge(geonet,poll_famord_5[,c("IGenus","Order","Family")], by = "IGenus")
colnames(geonet)[14:15]=c("PolOrder","PolFamily")
geonet <- geonet %>% mutate_if(is.factor,as.character)
geonet[geonet$PolFamily%in%c("Stenotritidae","Apidae","Andrenidae","Colletidae","Megachilidae","Melittidae","Halictidae"),c("PolOrder")]="Bee"
geonet[geonet$PolFamily%in%c("Syrphidae"),c("PolOrder")]="Syrphidae"

geonet <- geonet %>% mutate_if(is.character,as.factor)
str(geonet)



g=geonet%>%
group_by(Network, PolOrder) %>%
  summarise(order_links=sum(Int))

g2=g%>%
  group_by(Network) %>%
  summarise(int_tot=sum(order_links))

g3=merge(g,g2)

g3$prop_links=g3$order_links/g3$int_tot

g4=merge(g3,reference,by="Network")

#subset data by insect order
g.sub <- subset(g4, PolOrder %in% c("Hymenoptera", "Bee","Diptera", "Lepidoptera","Syrphidae","Coleoptera"))

```

```{r}
#################################################
#commpute jaccard parwise dissimilarity for null networks
#################################################

library(reshape2)
library(vegan)
library(plyr)
library(dplyr)

#################################
#start here
#################################

#cast long format dataframe
geo.wide <- dcast(geonet, Network + Plant ~ Pollinator, value.var = "Int")
geo.wide[is.na(geo.wide)] <- 0

#create empty list
null.net <- c()
null.net <- list(null.net)

#set max vector size
Sys.setenv('R_MAX_VSIZE'=32000000000)
start.time <- Sys.time()
#run loop over each site
for (j in levels(geo.wide[, 1])){
  web <- subset(geo.wide, Network == j)#iterate over site
  network <- as.vector(web$Network[1])
  web <- web[,c(-1,-2)]
  web = web[,colSums(web) > 0]#remove species with no links at each site
  web.names <- c(colnames(web))
  
  #Null model II from Bascompte et al. (2003). Creates random networks by probabilistically fixing row and column marginal totals. The expected number of links is same as observed number. Rodriguez-Girona and Santamaria (2006) showed that this null model has the best compromise between Type I and Type II errors
  #Run this code once to create the null model function
  null.model.II <- function(web){
    web <- as.matrix(web > 0) + 0
    # calculate the probability based on row marginals. Creates matrix same size as web, with row sums divided by number of columns (to get probability of a 1 in each cell of each row), repeated across all columns for each row.
    row.probs <- matrix(rowSums(web)/ncol(web),nrow(web),ncol(web))
    # calculate the probability based on column marginals (again, repeated for whole column). Transpose used instead of byrow=T
    col.probs <- t(matrix(colSums(web)/nrow(web),ncol(web),nrow(web)))
    # calculate the element by element mean of this probabilities
    mat.probs <- (row.probs + col.probs) / 2.0
    # generate a random matrix with 1s proportional to the above probabilities. rbinom(n, size, prob) n is number of observations, size is number of trials, prob is prob of success in each trial
    mat.null <- matrix(rbinom(nrow(web)*ncol(web),1,as.vector(mat.probs)),nrow(web),ncol(web))  
    # return that matrix in all its glory
    return(mat.null)
  }
  
  #Begin permutation test (two tailed)
  reps <- 999 #set number of permutations
  
  #Create a list with spaces for each output matrix  
  nulls<-vector("list",reps)  
  for (i in 1:reps) {
    nulls[[i]]<-null.model.II(web)
  }
  
  #call any individual matrix from that list using nulls[[x]], where x is the number of the matrix you want to call
  null.list <- vector("list") 
  for (i in 1:reps) {
    null.list[[i]] <- as.matrix(vegdist(t(nulls[[i]]), "jaccard", binary=T))#add colMeans if this doesn't work
  }

  #convert nans to nas
  null.list <- rapply(null.list, f=function(x) ifelse(is.nan(x),NA,x), how="replace" )

  #compute means and standard deviation for each species pair 
  null.mean <- apply(simplify2array(lapply(null.list, as.matrix)),1:2, mean, na.rm = TRUE)
  colnames(null.mean) <- web.names
  rownames(null.mean) <- web.names
  null.mean <- melt(null.mean, value.name="mean")
  null.sd <- apply(simplify2array(lapply(null.list, as.matrix)),1:2, sd, na.rm = TRUE)
  colnames(null.sd) <- web.names
  rownames(null.sd) <- web.names
  null.sd <- melt(null.sd,value.name="sd")
  null.mean.sd <- merge(null.mean,null.sd, by=c("Var1","Var2"))
  null.mean.sd <- null.mean.sd[!null.mean.sd$Var1==null.mean.sd$Var2,]
  null.mean.sd$network <- network
  
  #print into list
  null.net[[j]] <- null.mean.sd
  
}
  
#convert list to dataframe
null.net <- rbind.fill(lapply(null.net, as.data.frame))
colnames(null.net)=c("Poll_sp1","Poll_sp2","mean","sd","Network")

##Check system time
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
#################################
#END
#################################
```


```{r jaccard}
remove_zero_cols <- function(df) {
  rem_vec <- NULL
  for(i in 1:ncol(df)){
    this_sum <- summary(df[,i])
    zero_test <- length(which(this_sum == 0))
    if(zero_test == 6) {
      rem_vec[i] <- names(df)[i]
    }
  }
  features_to_remove <- rem_vec[!is.na(rem_vec)]
  rem_ind <- which(names(df) %in% features_to_remove)
  df <- df[,-rem_ind]
  return(df)
}

geo.split <- split(geo.wide,geo.wide$Network)

geo.split=lapply(geo.split,function(x)remove_zero_cols(x))

geo.split.jac=lapply(geo.split,function(x) vegdist(t(x[,3:length(x)]), method="jaccard",upper=T,binary=T))
geo.split.jac.long=lapply(geo.split.jac,function(x) melt(as.matrix(x)))
geo.split.jac.long=do.call("rbind",geo.split.jac.long)

geo.split.jac.long$Network=left(rownames(geo.split.jac.long),8)

head(geo.split.jac.long)
colnames(geo.split.jac.long)[1:2]=c("Poll_sp1","Poll_sp2")

str(geo.split.jac.long)

#GENUS 1
geo.split.jac.long$IGenus=word(gsub("\\."," ",geo.split.jac.long$Poll_sp1),1)

str(geo.split.jac.long)
geo.split.jac.long=merge(geo.split.jac.long,poll_famord_5[,c("IGenus","Order","Family")], by = "IGenus")

colnames(geo.split.jac.long)=c("PGenus1","Poll_sp1","Poll_sp2","jac","Network","Order1","Family1")

#GENUS 2
geo.split.jac.long$IGenus=word(gsub("\\."," ",geo.split.jac.long$Poll_sp2),1)

geo.split.jac.long=merge(geo.split.jac.long,poll_famord_5[,c("IGenus","Order","Family")], by = "IGenus")
str(geo.split.jac.long)

colnames(geo.split.jac.long)=c("PGenus2","PGenus1","Poll_sp1","Poll_sp2","jac","Network","Order1","Family1","Order2","Family2")
str(geo.split.jac.long)

geo.split.jac.long=merge(geo.split.jac.long,reference[,c("Latitude","Longitude","clim","Network","Connectance","ele")], by = "Network")
str(geo.split.jac.long)
head(geo.split.jac.long)

#MERGE WITH NULL DISTRIBUTION#####
setdiff(geo.split.jac.long$Poll_sp2,null.net$Poll_sp2)
null.geo=merge(geo.split.jac.long,null.net,by=c("Poll_sp1","Poll_sp2","Network"))%>%droplevels()

#compute z scores
null.geo$z <- (null.geo$jac - null.geo$mean)/null.geo$sd#print results into list
head(null.geo)
#########SUBSET########
null.geo <- null.geo %>% mutate_if(is.factor,as.character)
null.geo[null.geo$Family1%in%c("Stenotritidae","Apidae","Andrenidae","Colletidae","Megachilidae","Melittidae","Halictidae"),c("Order1")]="Bee"
null.geo[null.geo$Family1%in%c("Syrphidae"),c("Order1")]="Syrphidae"

null.geo[null.geo$Family2%in%c("Stenotritidae","Apidae","Andrenidae","Colletidae","Megachilidae","Melittidae","Halictidae"),c("Order2")]="Bee"
null.geo[null.geo$Family2%in%c("Syrphidae"),c("Order2")]="Syrphidae"

null.geo.sub1=subset(null.geo, Order1 %in% c("Hymenoptera", "Bee","Diptera", "Lepidoptera","Syrphidae","Coleoptera"))
null.geo.sub1=subset(null.geo.sub1, Order2 %in% c("Hymenoptera", "Bee","Diptera", "Lepidoptera","Syrphidae","Coleoptera"))
null.geo.sub1 <- null.geo.sub1 %>% mutate_if(is.character,as.factor)

null.geo.sub1$jac.fam=as.factor(paste(null.geo.sub1$Family1,null.geo.sub1$Family2,sep="_"))
null.geo.sub1$jac.ord=as.factor(paste(null.geo.sub1$Order1,null.geo.sub1$Order2,sep="_"))

null.geo.sub1$z

write.csv(null.geo.sub1,"data/null_niche.csv")

```

```{r jaccard z score model}
str(nullg)
hist(nullg$z)
range(nullg$z)
null.mod1=lm(z~clim*jac.ord,nullg)
summary(null.mod1)
plot(null.mod1)
lsmeans::lsmeans(null.mod1, pairwise ~ clim|jac.ord)
require(lme4)

lme.null=brm(z~clim*jac.ord+(scale(ele)|Network),nullg,cores=4)

sjPlot::plot_model(null.mod1)

ggplot(null.geo.sub1,aes(y=jac.ord,x=clim,col=clim))+facet_grid(~jac.ord)+geom_point()

```


```{r dissimilarity}

####PLANT FAMILY DISSIMILARITY####
pfdist=geonet %>% group_by(Network,clim,ele) %>% count(Pfamily)
pfdist=dcast(pfdist, Network + clim +ele ~ Pfamily, 
      fun.aggregate = sum, na.rm =T, value.var="n", fill = 0)
rownames(pfdist)=pfdist[,1]
str(pfdist)

pfdist.matrix=raupcrick(pfdist[,4:length(pfdist)],null="r1") #Presence-absence

mj=metaMDS(pfdist.matrix,k=3)

NMDS = data.frame(MDS1 = mj$points[,1], MDS2 = mj$points[,2],site=unique(pfdist$Network), clim=pfdist$clim)

#unable to create ellipse for B (to few points)... need to add them manually at some stage
NMDS <- subset(NMDS, clim %in% c("A", "C","D", "E"))%>%droplevels

#create ellipse function (this is hidden in vegan)
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100)
{
  theta <- (0:npoints) * 2 * pi/npoints
  Circle <- cbind(cos(theta), sin(theta))
  t(center + scale * t(Circle %*% chol(cov)))
}

df_ell <- data.frame()
for(g in levels(NMDS$clim)){
  df_ell <- rbind(df_ell, cbind(as.data.frame(with(NMDS[NMDS$clim==g,],
                                                   veganCovEllipse(cov.wt(cbind(MDS1,MDS2),wt=rep(1/length(MDS1),length(MDS1)))$cov,center=c(mean(MDS1),mean(MDS2)))))
                                ,group=g))
}

p <- ggplot(data = NMDS, aes(MDS1, MDS2))
p <- p + geom_point(aes(colour = clim), size=2)
#p <- p + geom_text(aes(label = site, colour=landuse), vjust = -0.8)
p <- p + geom_path(data=df_ell, aes(x=MDS1, y=MDS2,colour=group), size=1, linetype=2)
p <- p + theme(panel.grid.minor = element_blank(),
               panel.background = element_blank(),
               axis.line = element_line(colour = "black")) +
  theme(panel.border=element_rect(colour = "black", fill = "NA", size = 1)) +
  theme(axis.text.y=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =12),
        axis.title.y=element_text(size=16, vjust = 1),
        axis.text.x=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =12),
        axis.title.x=element_text(size=16, vjust = 1),
        axis.text=element_text(colour = "black"))
p <- p + theme(axis.title.y=element_text(margin=margin(0,20,0,0)))
p <- p + scale_colour_brewer(palette = "Dark2")

#################
#pollinator dissimilarity
####################
poldist=geonet %>% group_by(Network,clim,ele) %>% count(PolFamily)

poldist=dcast(poldist, Network + clim + ele ~ PolFamily, 
              fun.aggregate = sum, na.rm =T, value.var="n", fill = 0)
rownames(poldist)=poldist[,1]

poldist.matrix=raupcrick(poldist[,4:length(poldist)],null="r1") #Presence-absence

mj2=metaMDS(poldist.matrix,k=3)

NMDS1 = data.frame(MDS1 = mj2$points[,1], MDS2 = mj2$points[,2],site=unique(poldist$Network), clim=poldist$clim)

#unable to create ellipse for B (to few points)... need to add them manually at some stage
NMDS1 <- subset(NMDS1, clim %in% c("A", "C","D", "E"))%>%droplevels

#create ellipse function (this is hidden in vegan)
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100)
{
  theta <- (0:npoints) * 2 * pi/npoints
  Circle <- cbind(cos(theta), sin(theta))
  t(center + scale * t(Circle %*% chol(cov)))
}

df_ell <- data.frame()
for(g in levels(NMDS1$clim)){
  df_ell <- rbind(df_ell, cbind(as.data.frame(with(NMDS1[NMDS1$clim==g,],
                                                   veganCovEllipse(cov.wt(cbind(MDS1,MDS2),wt=rep(1/length(MDS1),length(MDS1)))$cov,center=c(mean(MDS1),mean(MDS2)))))
                                ,group=g))
}

p1 <- ggplot(data = NMDS1, aes(MDS1, MDS2))
p1 <- p1 + geom_point(aes(colour = clim), size=2)
#p <- p + geom_text(aes(label = site, colour=landuse), vjust = -0.8)
p1 <- p1 + geom_path(data=df_ell, aes(x=MDS1, y=MDS2,colour=group), size=1, linetype=2)
p1 <- p1 + theme(panel.grid.minor = element_blank(),
               panel.background = element_blank(),
               axis.line = element_line(colour = "black")) +
  theme(panel.border=element_rect(colour = "black", fill = "NA", size = 1)) +
  theme(axis.text.y=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =12),
        axis.title.y=element_text(size=16, vjust = 1),
        axis.text.x=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =12),
        axis.title.x=element_text(size=16, vjust = 1),
        axis.text=element_text(colour = "black"))
p1 <- p1 + theme(axis.title.y=element_text(margin=margin(0,20,0,0)))
p1 <- p1 + scale_colour_brewer(palette = "Dark2")


###PLOT BOTH TOGETHER
grid.arrange(p,p1)

```

```{r dissimilarity tests}

adonis(pfdist.matrix ~ pfdist$clim, permutations = 999)
adonis(pfdist.matrix ~ pfdist$clim+pfdist$ele, permutations = 999)
adonis(pfdist.matrix ~ pfdist$clim*scale(pfdist$ele), permutations = 999)
adonis(pfdist.matrix ~ pfdist$clim+scale(pfdist$ele), permutations = 999)
#very small amount explained by elevation

beta_plant=betadisper(pfdist.matrix, pfdist$clim, type = c("centroid"))
TukeyHSD(beta_plant) ## A FEW BAD

adonis(poldist.matrix ~ pfdist$clim, permutations = 999)
adonis(poldist.matrix ~ pfdist$clim+pfdist$ele, permutations = 999)
adonis(poldist.matrix ~ pfdist$clim*scale(pfdist$ele), permutations = 999)
adonis(poldist.matrix ~ pfdist$clim+scale(pfdist$ele), permutations = 999)
#more explained by elevation

beta_poll=betadisper(poldist.matrix, poldist$clim, type = c("centroid"))
TukeyHSD(beta_poll) ##ALL GOOD

##procrustes
pol.plant.pro=protest(poldist.matrix, pfdist.matrix,permutations=999)
pol.plant.pro

ctest <- data.frame(rda1=pol.plant.pro$Yrot[,1],
                    rda2=pol.plant.pro$Yrot[,2],xrda1=pol.plant.pro$X[,1],
                    xrda2=pol.plant.pro$X[,2])

p3=ggplot(ctest) +
  geom_point(aes(x=rda1, y=rda2),pch=1) +
  geom_point(aes(x=xrda1, y=xrda2),pch=2) +
  geom_segment(aes(x=xrda1,y=xrda2,xend=rda1,yend=rda2),arrow=arrow(length=unit(0.2,"cm")))+
  theme_bw()+ylab("Dimension 2")+xlab("Dimension 1")+theme(aspect.ratio = 1)
p3

```


```{r test prop links across climate and elevation}
library(MuMIn)
library(lme4)
library(stargazer)
library(DHARMa)
g.sub


reference$clim=as.factor(reference$clim)
as.numeric(reference$clim)
str(g.sub)
##FULL MODEL - THREE WAY INTERACTION
prop1=glmmTMB(prop_links~PolOrder*clim+(1+scale(ele)|Network),
              family=beta_family(link = "logit"),
              data=g.sub)
AIC(prop1)
summary(prop1)
plot(residuals(prop1)~fitted(prop1))
prop.res=simulateResiduals(prop1)
plot(prop.res) #THESE ARE GREAST

summary(prop1)

prop.dredge=dredge(prop1)

prop.mods=get.models(prop.dredge, subset = delta < 4)
summary(prop.mods[[1]])


sjPlot::plot_model(prop1,vline.color="black")+theme_bw()

prop2=brm(prop_links~0+PolOrder*clim+(scale(ele)|Network),
              family=beta_family(link = "logit"),
              data=g.sub,cores=4)
pp_check(prop2,nsamples=100)
loo(prop2)
bayes_R2(prop2)

```



```{r specialisation}


#################################################
#correct number of links for sampling effort with Bascompte null model
#################################################
library(reshape2)
library(vegan)
library(plyr)
library(dplyr)
library(ggplot2)

#cast long format dataframe
geo.wide <- dcast(geonet, Network + Plant ~ Pollinator, value.var = "Int")
geo.wide[is.na(geo.wide)] <- 0

#gg <- subset(geo.wide, Network %in% c("M_PL_001")) %>% droplevels
#create empty listy
sp.links <- c()
sp.links <- list(sp.links)

#run loop over each site
for (j in levels(geo.wide[, 1])){
  web <- subset(geo.wide, Network == j)#iterate over site
  web <- web[,c(-1,-2)]
  web = web[,colSums(web) > 0]#remove species with no links at each site

#Null model II from Bascompte et al. (2003). Creates random networks by probabilistically fixing row and column marginal totals. The expected number of links is same as observed number. Rodriguez-Girona and Santamaria (2006) showed that this null model has the best compromise between Type I and Type II errors
#Run this code once to create the null model function
null.model.II <- function(web){
  web <- as.matrix(web > 0) + 0
  # calculate the probability based on row marginals. Creates matrix same size as web, with row sums divided by number of columns (to get probability of a 1 in each cell of each row), repeated across all columns for each row.
  row.probs <- matrix(rowSums(web)/ncol(web),nrow(web),ncol(web))
  # calculate the probability based on column marginals (again, repeated for whole column). Transpose used instead of byrow=T
  col.probs <- t(matrix(colSums(web)/nrow(web),ncol(web),nrow(web)))
  # calculate the element by element mean of this probabilities
  mat.probs <- (row.probs + col.probs) / 2.0
  # generate a random matrix with 1s proportional to the above probabilities. rbinom(n, size, prob) n is number of observations, size is number of trials, prob is prob of success in each trial
  mat.null <- matrix(rbinom(nrow(web)*ncol(web),1,as.vector(mat.probs)),nrow(web),ncol(web))  
  # return that matrix in all its glory
  return(mat.null)
}

#Begin permutation test (two tailed)
reps <- 999 #set number of permutations

nulls<-vector("list",reps)  # Create a list with spaces for each output matrix
for (i in 1:reps) {
  nulls[[i]]<-null.model.II(web)
}

#call any individual matrix from that list using nulls[[x]], where x is the number of the matrix you want to call
null.links <- data.frame(matrix(, nrow=reps, ncol(web)))
for (i in 1:reps) {
  null.links[i, ] <- t(colSums(nulls[[i]]))
}

weblink <- t(colSums(as.matrix(web > 0) + 0))
colnames(null.links) <- colnames(weblink)
links <- rbind(null.links,weblink)#Add observed connectance into distribution
sd <- apply(null.links, 2, sd)#calculate standard deviation
sp.links[[j]] <- abs(weblink - colMeans(null.links)/sd)#print results into list

}

#convert list to dataframe and melt
sp.links.df <- rbind.fill(lapply(sp.links, as.data.frame))
sp.links.df$Network <- levels(geonet$Network)
sp.links.melt <- melt(sp.links.df, "Network", variable.name = "Pollinator", value.name = "value", na.rm = TRUE)

#add order and family to dataframe
geo.uni <- unique(geonet[c("Pollinator", "PolFamily", "PolOrder")])
sp.links.order <- merge(sp.links.melt,geo.uni, by="Pollinator")
sp.links.order <- merge(sp.links.order,reference[,c("Network","ele","clim")], by="Network")
ord <- c("Hymenoptera", "Bee","Diptera", "Lepidoptera","Syrphidae","Coleoptera")
sp.links.order.sub <- filter(sp.links.order, PolOrder %in% ord)



#plot generalisation by climate zone
p <- ggplot()
p <- p + xlab("Climate zone") + ylab("Number of links (Z score)")
p <- p + theme(text = element_text(size=18))
p <- p + geom_boxplot(data=sp.links.order.sub, aes(x=clim, y=log(value), color=PolOrder))
p <- p + geom_jitter(data=links.clim.sub, aes(x=clim, y=value, color=PolOrder, fill=PolOrder),
                     alpha=1, size=2.5, position = position_jitter(width = 0.25))
p
p <- p + facet_wrap(~PolOrder, scales="free")
p <- p + theme(panel.grid.minor = element_blank(),
               panel.background = element_blank(),
               axis.line = element_line(colour = "black")) +
  theme(panel.border=element_rect(colour = "black", fill = "NA", size = 1)) +
  theme(axis.text.x=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =16),
        axis.text.y=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =16),
        axis.title.y=element_text(size=24, vjust = 1),
        axis.title.x=element_text(size=24, vjust = 1),
        axis.text=element_text(colour = "black"))+
  theme(strip.background = element_rect(colour="NA", fill=NA),
        strip.text = element_text(size=20))
p <- p + theme(panel.spacing.x=unit(1, "lines"),panel.spacing.y=unit(1, "lines"))
p <- p + theme(axis.title.y=element_text(margin=margin(0,20,0,0)))
p <- p + scale_color_brewer(palette="Set2")
p <- p + scale_fill_brewer(palette="Set2")
p <- p + theme(legend.position="none")
p

#plot generalisation on world map
WorldData <- map_data('world')
WorldData %>% filter(region != "Antarctica") -> WorldData
WorldData <- fortify(WorldData)

map <- ggplot()
map <- map + xlab("Longitude") + ylab("Latitude")
map <- map + geom_map(data=WorldData, map=WorldData,
                  aes(x=long, y=lat, group=group, map_id=region))
#map <- map + geom_point(data=filter(links.clim, Order == "Coleoptera"),
map <- map + geom_point(data=sp.links.order.sub,
                        aes(x=Longitude, y=Latitude, colour=log(value)),size=2)
map <- map + scale_colour_gradient(low="green",high="red")
map <- map + facet_wrap(PolOrder~clim,ncol = 5)
map <- map + theme(axis.line.x = element_line(size=.5, colour = "black"),
                   axis.line.y = element_line(size=.5, colour = "black"),
                   panel.grid.major = element_line(colour = "#d3d3d3"),
                   panel.grid.minor = element_blank(),
                   panel.border = element_blank(), panel.background = element_blank()) +
  theme(axis.text.x=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =14),
        axis.title.x=element_text(size=30, vjust = 1),
        axis.text.y=element_text(angle= 360, hjust = 0.5, vjust = 0.5, size =14),
        axis.title.y=element_text(size=30, vjust = 1),
        axis.text=element_text(colour = "black"))+
  theme(axis.ticks.length = unit(2, "mm"))+
  theme(strip.background = element_rect(colour="NA", fill=NA),
        strip.text = element_text(size=14))
map <- map + theme(axis.title.y=element_text(margin=margin(0,20,0,0)))
map

#################################################
#END
#################################################
#################################################
#END
#################################################
```


```{r specialisation model}

str(sp.links.order)
range(sp.links.order$value)
gen.spec=brm(value~PolOrder*clim+(scale(ele)|Network),
              family="gaussian",
              data=sp.links.order,cores=4)


```
